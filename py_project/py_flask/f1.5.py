#주소를 쳐서 요청할 때 끝에 /를 붙일 것인가 아닌가?

####################################################
#클라이언트가 웹페이지를 요청할 때 데이터를 보내고 싶다
# 데이터를 보내는 방법 : method(get, post,...), 동적 파라미터
#페이지를 요청할 때 데이터 보내기 : method 방식
# get : url?uid=ppp&age=10 (key=값)
# uid,age 등은  키 값 &는 (키=값) 세트를 연결하는 구분자
# get은 헤더 타고 들어감 바디가 없음!
# 문제점 : 데이터가 눈에 보인다 --> 보안에 취약하다 , 대용량 데이터 , 큰 데이터는 전송 불가 -> 짤림
# 왜-->(http 프로토콜의  헤더(머리)의 데이터를 세팅해서 전달하기 때문에 공간이 적다.)
# 장점 : 구성이 편하고, 전달도 빠르다.(상대적)


#1. 모듈 가져오기
from flask import Flask,request
 #flask 모듈로부터 flask 클래스를 가져옴 - pip install flask 로 설치
#pip list - 설치된 모듈 확인

  
# 1. 모듈 가져오기
#2. 앱 생성(서버 생성)
app = Flask(__name__)

# 3. 라우팅(요청을 분석하여 어떤 함수가 응답할지 매칭해주는 것)
# 요청 : http +:// + 아이피 + : +포트+/+세부페이지이동
#/pro 나 or /pro/ 이것을 다같이 같은 url로 인식시키는 방법
#/pro 요청 -> /pro/
#/pro/ 요청 -> /pro/
#라우트에서 요청 주소를 정의할 때 끝에 슬래쉬 붙여주기
@app.route('/pro/') 
#아무런 세팅이 없으면 기본 get 방식으로 요청함을 의미한다.
def home() : #응답함수
    return 'home page %s'%request.method

# 4. 서버 가동
if __name__ =="__main__" : #main이 될때만 서버 작동
    # 디버깅 모드를 사용하면 내가 수정한 내용이 반영되어 자동으로 재가동됨 -> 즉 자동반영된다.
    #초기값이 설정되어있지 않다는 것은 기본설정값이 False 라는 것이기 때문에 debug를 True로 바꿔줌
    # app.run(debug=True)
    # 서버주소는 ip와 포트주소로 구성 : 기본 포트는 5000번을 사용하는데 통상 80번은 생략 가능
    # 포트란?  http://127.0.0.1:5000/ 포트는 기본 아이피에서 0~65535개 포트를 사용할 수있음
    # 같은 ip주소(장비)에 할당되는 수십개의 프로그램이 구동되기 위해  
    app.debug=True
    app.run() 
else :
    print("본 모듈은 단독으로 구동될때만 정상 작동합니다.")